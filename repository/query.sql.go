// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package repository

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createClinic = `-- name: CreateClinic :one
INSERT INTO clinics (clinic_name, user_id)
VALUES ($2, $1) RETURNING id, user_id, clinic_name, address, phone_number, created_at
`

type CreateClinicParams struct {
	UserID     uuid.UUID `json:"user_id"`
	ClinicName string    `json:"clinic_name"`
}

func (q *Queries) CreateClinic(ctx context.Context, arg CreateClinicParams) (Clinic, error) {
	row := q.db.QueryRowContext(ctx, createClinic, arg.UserID, arg.ClinicName)
	var i Clinic
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ClinicName,
		&i.Address,
		&i.PhoneNumber,
		&i.CreatedAt,
	)
	return i, err
}

const createExamination = `-- name: CreateExamination :one
INSERT INTO Examinations (patient_id, clinic_id, examinations_type, examination_data)
    VALUES ($1, $2, $3, $4) RETURNING id, patient_id, clinic_id, examinations_type, examination_data, created_at
`

type CreateExaminationParams struct {
	PatientID        uuid.UUID       `json:"patient_id"`
	ClinicID         uuid.UUID       `json:"clinic_id"`
	ExaminationsType string          `json:"examinations_type"`
	ExaminationData  json.RawMessage `json:"examination_data"`
}

func (q *Queries) CreateExamination(ctx context.Context, arg CreateExaminationParams) (Examination, error) {
	row := q.db.QueryRowContext(ctx, createExamination,
		arg.PatientID,
		arg.ClinicID,
		arg.ExaminationsType,
		arg.ExaminationData,
	)
	var i Examination
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.ClinicID,
		&i.ExaminationsType,
		&i.ExaminationData,
		&i.CreatedAt,
	)
	return i, err
}

const createPatient = `-- name: CreatePatient :one
INSERT INTO Patients (last_name, first_name, date_of_birth, national_id)
VALUES ($1, $2, $3, $4)  -- Replace with the actual national_id
ON CONFLICT (national_id) 
DO UPDATE SET national_id = EXCLUDED.national_id  -- Dummy update to trigger the conflict handling
RETURNING id
`

type CreatePatientParams struct {
	LastName    string    `json:"last_name"`
	FirstName   string    `json:"first_name"`
	DateOfBirth time.Time `json:"date_of_birth"`
	NationalID  string    `json:"national_id"`
}

func (q *Queries) CreatePatient(ctx context.Context, arg CreatePatientParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createPatient,
		arg.LastName,
		arg.FirstName,
		arg.DateOfBirth,
		arg.NationalID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO Users (email, password)
VALUES ($1, $2) RETURNING id, email, password, created_at
`

type CreateUserParams struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const getAllClinics = `-- name: GetAllClinics :many
SELECT id, user_id, clinic_name, address, phone_number, created_at FROM Clinics offset $1 limit $2
`

type GetAllClinicsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetAllClinics(ctx context.Context, arg GetAllClinicsParams) ([]Clinic, error) {
	rows, err := q.db.QueryContext(ctx, getAllClinics, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Clinic
	for rows.Next() {
		var i Clinic
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ClinicName,
			&i.Address,
			&i.PhoneNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPatients = `-- name: GetAllPatients :many
SELECT id, first_name, last_name, date_of_birth, national_id, created_at FROM Patients
`

func (q *Queries) GetAllPatients(ctx context.Context) ([]Patient, error) {
	rows, err := q.db.QueryContext(ctx, getAllPatients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Patient
	for rows.Next() {
		var i Patient
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.NationalID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClinicByEmail = `-- name: GetClinicByEmail :one
SELECT Clinics.id
FROM Clinics
JOIN Users ON Clinics.user_id = Users.id
WHERE Users.email = $1
`

func (q *Queries) GetClinicByEmail(ctx context.Context, email string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getClinicByEmail, email)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getClinicByID = `-- name: GetClinicByID :one
SELECT id, user_id, clinic_name, address, phone_number, created_at FROM Clinics WHERE id = $1
`

func (q *Queries) GetClinicByID(ctx context.Context, id uuid.UUID) (Clinic, error) {
	row := q.db.QueryRowContext(ctx, getClinicByID, id)
	var i Clinic
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ClinicName,
		&i.Address,
		&i.PhoneNumber,
		&i.CreatedAt,
	)
	return i, err
}

const getPatientHistoryByNationalId = `-- name: GetPatientHistoryByNationalId :many

SELECT Examinations.examination_data, Examinations.examinations_type, Patients.date_of_birth, Patients.first_name, Patients.last_name, Patients.national_id, Examinations.created_at
FROM Examinations
INNER JOIN Patients ON Examinations.patient_id = Patients.id
WHERE Patients.national_id = $1
`

type GetPatientHistoryByNationalIdRow struct {
	ExaminationData  json.RawMessage `json:"examination_data"`
	ExaminationsType string          `json:"examinations_type"`
	DateOfBirth      time.Time       `json:"date_of_birth"`
	FirstName        string          `json:"first_name"`
	LastName         string          `json:"last_name"`
	NationalID       string          `json:"national_id"`
	CreatedAt        sql.NullTime    `json:"created_at"`
}

// Replace $1 with the user email parameter
func (q *Queries) GetPatientHistoryByNationalId(ctx context.Context, nationalID string) ([]GetPatientHistoryByNationalIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getPatientHistoryByNationalId, nationalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPatientHistoryByNationalIdRow
	for rows.Next() {
		var i GetPatientHistoryByNationalIdRow
		if err := rows.Scan(
			&i.ExaminationData,
			&i.ExaminationsType,
			&i.DateOfBirth,
			&i.FirstName,
			&i.LastName,
			&i.NationalID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password, created_at FROM Users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}
