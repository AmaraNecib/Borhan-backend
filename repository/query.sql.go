// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package repository

import (
	"context"

	"github.com/google/uuid"
)

const createClinic = `-- name: CreateClinic :one
INSERT INTO clinics (clinic_name, user_id)
VALUES ($2, $1) RETURNING id, user_id, clinic_name, address, phone_number, created_at
`

type CreateClinicParams struct {
	UserID     uuid.UUID `json:"user_id"`
	ClinicName string    `json:"clinic_name"`
}

func (q *Queries) CreateClinic(ctx context.Context, arg CreateClinicParams) (Clinic, error) {
	row := q.db.QueryRowContext(ctx, createClinic, arg.UserID, arg.ClinicName)
	var i Clinic
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ClinicName,
		&i.Address,
		&i.PhoneNumber,
		&i.CreatedAt,
	)
	return i, err
}

const createPatient = `-- name: CreatePatient :one
INSERT INTO Patients (national_id)
    VALUES ($1)  -- Replace with the actual national_id
    ON CONFLICT (national_id) DO NOTHING
    RETURNING id
`

func (q *Queries) CreatePatient(ctx context.Context, nationalID string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createPatient, nationalID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO Users (email, password)
VALUES ($1, $2) RETURNING id, email, password, created_at
`

type CreateUserParams struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const getAllClinics = `-- name: GetAllClinics :many
SELECT id, user_id, clinic_name, address, phone_number, created_at FROM Clinics offset $1 limit $2
`

type GetAllClinicsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetAllClinics(ctx context.Context, arg GetAllClinicsParams) ([]Clinic, error) {
	rows, err := q.db.QueryContext(ctx, getAllClinics, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Clinic
	for rows.Next() {
		var i Clinic
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ClinicName,
			&i.Address,
			&i.PhoneNumber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTables = `-- name: GetTables :many
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public'
`

func (q *Queries) GetTables(ctx context.Context) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, getTables)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var table_name interface{}
		if err := rows.Scan(&table_name); err != nil {
			return nil, err
		}
		items = append(items, table_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password, created_at FROM Users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const info = `-- name: Info :many
SELECT current_database()
`

func (q *Queries) Info(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, info)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var current_database string
		if err := rows.Scan(&current_database); err != nil {
			return nil, err
		}
		items = append(items, current_database)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
